### 8.2 静态散列

- 在静态散列方法中，把标识符存储在一个固定大小的表中，该表称为 **「散列表 hash table」**。
- 使用一个函数 $$f$$ 确定标识符 $$x$$ 在散列表中的地址（或位置）。因此，$$f(x)$$ 给出了 $$x$$ 在散列表中的散列地址（或标识地址）。散列表 $$ht$$ 存放在一片连续的内存空间中，该空间被分割为 $$b$$ 个散列桶：$$ht[0], \cdots, ht[b-1]$$。每个散列桶包含有 $$s$$ 个槽，通常 $$s = 1$$。标识符 $$x$$ 所有可能的取值共有 $$T$$ 个。
- **「标识符密度 identifier density」** $$= n/T$$。
- **「装载密度 loading density」** 或 **「装载因子 loading factor」** 定义为 $$\alpha = n/(sb)$$。
- 由于散列表中的散列桶的数量 $$b$$ 通常比所有可能出现的标识符的数量 $$T$$ 小几个量级，所以散列函数 $$f$$ 就必定会将不同的标识符映射到相同的散列桶中。如果 $$f(i_1) = f(i_2)$$，则称标识符 $$i_1$$ 和 $$i_2$$ 是关于 $$f$$ 的同义词。但是，当把一个新的标识符 $$i$$ 映射到一个已经满的散列桶（即没有空闲槽）中时，就会发生 **「溢出 overflow」**。把两个不同的标识符散列到同一个散列桶中的现象称为 **「冲突 collision」**。当散列桶的大小为 1 时，冲突和溢出同时发生。
- 例如一散列表 $$ht$$，具有 $$b = 26$$ 个散列桶、每个散列桶有 $$s = 2$$ 个槽。现在有 $$n = 10$$ 个不同的标识符：acos, define, float, exp, char, atan, ceil, floor, clock, ctime。该散列表的装载因子是 $$\alpha = 10/52 = 0.19$$。可以构造一个非常简单的散列函数：把字符 a ~ z 分别与这 26 个散列桶相对应，然后把散列函数 $$f(x)$$ 定义为 $$x$$ 的首字符。那么这些标识符分别散列到散列桶 0, 3, 5, 4, 2, 0, 2, 5, 2, 2。如下表。当标识符 clock 散列到散列桶 $$ht[2]$$ 上时，由于这个散列桶已满，所以就会产生溢出。在散列表上插入、删除或查找一个标识符所需的时间复杂度为 $$O(1)$$。

$$b$$ | 槽 0 | 槽 1
:-: | :-: | :-:
0 | acos | atan
1 | |
2 | char | ceil
3 | define |
4 | exp |
5 | float | floor
6 | |
... | |
25 | |

- 在散列表中，任意的标识符 $$x$$ 可以等概率地散列到 $$b$$ 个散列桶上。称满足这种性质的散列函数为 **「均匀分布散列函数 uniform hash function」**。
