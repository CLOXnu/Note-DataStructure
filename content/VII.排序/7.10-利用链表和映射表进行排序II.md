### 7.10 利用链表和映射表进行排序 II

对于堆排序而言，堆的顺序表示是进行哦嗲是操作的基础。利用辅助表来对表中的记录进行间接引用，就可以消除排序过程中不必要的数据移动。辅助表定义为 `int table[MAX_SIZE]`，在下面的分析中用 $$t$$ 来表示。在排序开始时，$$t[i] = i (0 \leq i \leq n-1)$$。如果排序算法需要交换记录 $$R_i$$ 和 $$R_j$$，则交换表中的 $$t[i]$$ 和 $$t[j]$$，而原来的表无需改变。排序后的表为 $$R_{t[0]}, R_{t[1]}, \cdots, R_{t[n-1]}$$。即 $$R_{t[0]}$$ 中存放的是关键字最小的记录，$$R_{t[n-1]}$$ 中存放的是关键字最大的记录。

<div align="center">
    <img src="res/7-8.svg" width="300px">
    <p style="color:#3ea69f">
    利用映射表进行排序
    </p>
</div>

与排列 $$t[0], t[1], \cdots, t[n-1]$$ 相对应的记录重排算法是以下数学定理的一个相当有趣的应用：每个排列都由若干个互不相交的循环组成。任意元素 $$i$$ 的循环由元素 $$t[i], t^2[i], \cdots, t^k[i]$$ 组成，其中 $$t^j[i] = t[t^{j-1}[i]]$$，且 $$t^0[i] = i$$ 和 $$t^k[i] = i$$。如上图有两个环组成：$$t[0] = 4$$ 且 $$t[4] = 0$$，包含 $$R_0$$ 和 $$R_4$$，第二个环 $$t[1] = 3, t[3] = 2, t[2] = 1$$，包含 $$R_3, R_2$$ 和 $$R_1$$。函数 `table_sort` 使用排列的循环分解。首先，考察包含记录 $$R_0$$ 的循环并把包含 $$R_0$$ 的循环的所有记录都移到正确的位置上。然后，如果 $$R_1$$ 和 $$R_0$$ 不在同一个循环中，则考察包含记录 $$R_1$$ 的循环排列。再按上述方式依次检查包含 $$R_2, R_3, \cdots, R_{n-2}$$ 的循环。结果就得到表的物理排序。

```c++
void table_sort(element list[], int n, int table[])
{
    // 重排 list[0], ..., list[n-1] 对应于 list[table[0]] ,..., list[table[n-1]]
    int i, current, next;
    element temp;
    for (i = 0; i < n-1; i++)
        if (table[i] != 1) {
            temp = list[i];
            current = i;
            do {
                next = table[current];
                list[current] = list[next];
                table[current] = current;
                current = next;
            } while (table[current] != i);
            list[current] = temp;
            table[current] = current;
        }
}
```
