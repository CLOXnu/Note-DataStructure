'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var querystring = require('querystring');
var btoa = require('btoa');
var fetch = require('isomorphic-fetch');

var GitBookError = require('./error');
var defaultConfig = require('./defaultConfig');

/**
 * ApiClient is a helper class to make API requests
 * from React components using the user's token and the
 * API Secret as password for BasicAuth.
 *
 * @type {Class}
 */

var ApiClient = function () {

    /**
     * Initialize a new API Client from configuration and a JSON encoded account
     *
     * @param  {Object} config
     * @param  {Object} account
     */
    function ApiClient() {
        var account = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;

        _classCallCheck(this, ApiClient);

        // config.apiHost and account.auth.token are used
        // to keep compatibility with GitBook.com payload.

        // Set base URL for requests
        this.endpoint = config.host || config.apiHost;

        // Set Basic Auth informations
        this.auth = undefined;

        if (account.username && account.token) {
            this.auth = 'Basic ' + btoa(account.username + ':' + account.token);
        } else if (account.token) {
            this.auth = 'Bearer ' + account.token;
        }

        // Set common headers
        this.headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': this.auth
        };
    }

    /**
     * Return true if api calls are authentified
     */


    _createClass(ApiClient, [{
        key: 'isAuthenticated',
        value: function isAuthenticated() {
            return Boolean(this.auth);
        }

        /**
         * enpointUrl returns the full targeted URL with API host and encoded querystring
         * @param  {String} url     Relative URL to API endpoint
         * @param  {Object} params  Object containing query string parameters to encode
         * @return {String}
         */

    }, {
        key: 'endpointUrl',
        value: function endpointUrl(url, params) {
            url = url[0] == '/' ? url : '/' + url;
            return this.endpoint + url + (params ? '?' + querystring.stringify(params) : '');
        }

        /**
         * request executes the request to an API endpoint <url> with options <opts>
         * It returns a Promise providing the data from the response as a JS Object
         *
         * @param  {String} url
         * @param  {Object} opts  <opts> may contain the following properties:
         *                        - {String} method: HTTP method for the request
         *                        - {Object} data:   Body for the request to be encoded as JSON
         *                        - {Object} params: An Object containing the query string parameters to encode
         * @return {Promise}
         */

    }, {
        key: 'request',
        value: function request(url) {
            var _this = this;

            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // Configuration for fetch
            var cfg = {
                method: opts.method || 'GET',
                headers: _extends({}, this.headers, opts.headers || {})
            };

            if (Boolean(opts.data)) {
                cfg.body = JSON.stringify(opts.data);
            }

            // Construct full URL
            url = this.endpointUrl(url, opts.params);

            return fetch(url, cfg).then(function (response) {
                return _this.parseResponse(response);
            });
        }

        /**
         * delete is a shorthand method to send a DELETE HTTP request
         * See request description for more details about <url>, <params> and return type
         * @param  {String} url
         * @param  {Object} params
         * @return {Promise}
         */

    }, {
        key: 'delete',
        value: function _delete(url, params) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            return this.request(url, _extends({}, options, {
                method: 'DELETE',
                params: params
            }));
        }

        /**
         * get is a shorthand method to send a GET HTTP request
         * See request description for more details about <url>, <params> and return type
         * @param  {String} url
         * @param  {Object} params
         * @return {Promise}
         */

    }, {
        key: 'get',
        value: function get(url, params) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            return this.request(url, _extends({}, options, {
                params: params
            }));
        }

        /**
         * patch is a shorthand method to send a PATCH HTTP request
         * See request description for more details about <url>, <data>, <params> and return type
         * @param  {String} url
         * @param  {Object} params
         * @param  {Object} data
         * @return {Promise}
         */

    }, {
        key: 'patch',
        value: function patch(url, data) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            return this.request(url, _extends({}, options, {
                method: 'PATCH',
                data: data
            }));
        }

        /**
         * post is a shorthand method to send a POST HTTP request
         * See request description for more details about <url>, <data>, <params> and return type
         * @param  {String} url
         * @param  {Object} params
         * @param  {Object} data
         * @return {Promise}
         */

    }, {
        key: 'post',
        value: function post(url, data) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            return this.request(url, _extends({}, options, {
                method: 'POST',
                data: data
            }));
        }

        /**
         * put is a shorthand method to send a PUT HTTP request
         * See request description for more details about <url>, <data>, <params> and return type
         * @param  {String} url
         * @param  {Object} params
         * @param  {Object} data
         * @return {Promise}
         */

    }, {
        key: 'put',
        value: function put(url, data) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            return this.request(url, _extends({}, options, {
                method: 'PUT',
                data: data
            }));
        }

        /**
         * parseResponse is responsible for handling the response to a fetch request
         * It checks that <response> was successfull and contains the correct Content-Type
         * It returns a Promise for trying to parse the encoded JSON body to a JS Object
         *
         * @param  {Response} response
         * @return {Promise}
         */

    }, {
        key: 'parseResponse',
        value: function parseResponse(response) {
            var contentType = response.headers.get('Content-Type');

            if (!response.ok) {
                return GitBookError.createForResponse(response);
            }

            if (contentType.indexOf('application/json') < 0) {
                throw new Error('Invalid content type for response');
            }

            return response.json();
        }
    }]);

    return ApiClient;
}();

module.exports = ApiClient;